#!/bin/bash

ANSIBLE_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${ANSIBLE_SCRIPT_DIR}/../utils/logging.sh"

ANSIBLE_BASE_DIR="ansible"
ANSIBLE_PLAYBOOK_DIR="${ANSIBLE_BASE_DIR}/playbooks"
ANSIBLE_INVENTORY_DIR="${ANSIBLE_BASE_DIR}/inventories"
ANSIBLE_ROLES_DIR="${ANSIBLE_BASE_DIR}/roles"
SUPPORTED_PLATFORMS=("aws" "proxmox")

ANSIBLE_HOST_KEY_CHECKING="False"
ANSIBLE_STDOUT_CALLBACK="yaml"
ANSIBLE_CALLBACKS_ENABLED="profile_tasks"

is_ansible_platform_supported() {
    local platform="$1"
    for supported in "${SUPPORTED_PLATFORMS[@]}"; do
        if [ "$platform" = "$supported" ]; then
            return 0
        fi
    done
    return 1
}

validate_ansible_directory() {
    step "Validating Ansible directory structure..."

    if [ ! -d "$ANSIBLE_BASE_DIR" ]; then
        error "Ansible directory not found: $ANSIBLE_BASE_DIR"
        return 1
    fi

    if [ ! -d "$ANSIBLE_PLAYBOOK_DIR" ]; then
        error "Ansible playbooks directory not found: $ANSIBLE_PLAYBOOK_DIR"
        info "Create with: mkdir -p $ANSIBLE_PLAYBOOK_DIR"
        return 1
    fi

    if [ ! -d "$ANSIBLE_INVENTORY_DIR" ]; then
        error "Ansible inventories directory not found: $ANSIBLE_INVENTORY_DIR"
        info "Create with: mkdir -p $ANSIBLE_INVENTORY_DIR"
        return 1
    fi

    success "Ansible directory structure is valid"
    return 0
}

validate_inventory() {
    local platform="$1"
    local inventory_file="${ANSIBLE_INVENTORY_DIR}/${platform}/hosts.ini"

    step "Validating inventory file for $platform..."

    if [ ! -f "$inventory_file" ]; then
        error "Inventory file not found: $inventory_file"
        info "This file should be generated by Terraform or created manually"
        return 1
    fi

    if [ ! -s "$inventory_file" ]; then
        error "Inventory file is empty: $inventory_file"
        info "Please populate it with your server information"
        return 1
    fi

    # Basic validation of inventory format
    if ! grep -q "\[.*\]" "$inventory_file"; then
        warn "Inventory file may not be in proper INI format"
    fi

    success "Inventory file is valid"
    return 0
}

validate_playbook() {
    local playbook="$1"
    local playbook_path="${ANSIBLE_PLAYBOOK_DIR}/${playbook}"

    if [ ! -f "$playbook_path" ]; then
        error "Playbook not found: $playbook_path"
        return 1
    fi

    if command -v yamllint >/dev/null 2>&1; then
        if ! yamllint "$playbook_path" >/dev/null 2>&1; then
            warn "Playbook may have YAML syntax issues: $playbook_path"
        fi
    fi

    return 0
}

set_ansible_env() {
    export ANSIBLE_HOST_KEY_CHECKING="$ANSIBLE_HOST_KEY_CHECKING"
    export ANSIBLE_STDOUT_CALLBACK="$ANSIBLE_STDOUT_CALLBACK"
    export ANSIBLE_CALLBACKS_ENABLED="$ANSIBLE_CALLBACKS_ENABLED"
    export ANSIBLE_FORCE_COLOR="true"

    debug "Ansible environment variables set"
}

run_ansible_playbook() {
    local platform="$1"
    local playbook="$2"
    local extra_vars="${3:-}"
    local tags="${4:-}"
    local limit="${5:-}"
    local check_mode="${6:-false}"

    local inventory_file="${ANSIBLE_INVENTORY_DIR}/${platform}/hosts.ini"
    local playbook_path="${ANSIBLE_PLAYBOOK_DIR}/${playbook}"

    step "Running Ansible playbook: $playbook for $platform"

    local cmd="ansible-playbook -i $inventory_file $playbook_path"

    if [ -n "$extra_vars" ]; then
        cmd="$cmd --extra-vars '$extra_vars'"
    fi

    if [ -n "$tags" ]; then
        cmd="$cmd --tags '$tags'"
    fi

    if [ -n "$limit" ]; then
        cmd="$cmd --limit '$limit'"
    fi

    if [ "$check_mode" = "true" ]; then
        cmd="$cmd --check"
        info "Running in check mode (dry run)"
    fi

    debug "Executing: $cmd"

    eval $cmd
    local exit_code=$?

    if [ $exit_code -eq 0 ]; then
        success "Ansible playbook completed successfully"
        return 0
    else
        error "Ansible playbook failed with exit code: $exit_code"
        return $exit_code
    fi
}

ansible_ping() {
    local platform="$1"
    local inventory_file="${ANSIBLE_INVENTORY_DIR}/${platform}/hosts.ini"

    step "Testing connectivity to $platform hosts..."

    if ansible all -i "$inventory_file" -m ping; then
        success "All hosts are reachable"
        return 0
    else
        error "Some hosts are not reachable"
        return 1
    fi
}

ansible_gather_facts() {
    local platform="$1"
    local inventory_file="${ANSIBLE_INVENTORY_DIR}/${platform}/hosts.ini"

    step "Gathering facts from $platform hosts..."

    ansible all -i "$inventory_file" -m setup
}

ansible_adhoc() {
    local platform="$1"
    local module="$2"
    local args="${3:-}"
    local hosts="${4:-all}"

    local inventory_file="${ANSIBLE_INVENTORY_DIR}/${platform}/hosts.ini"

    step "Running ad-hoc command on $platform hosts..."

    local cmd="ansible $hosts -i $inventory_file -m $module"

    if [ -n "$args" ]; then
        cmd="$cmd -a '$args'"
    fi

    debug "Executing: $cmd"
    eval $cmd
}

install_ansible_requirements() {
    step "Installing Ansible requirements..."

    local requirements_file="${ANSIBLE_BASE_DIR}/requirements.yml"

    if [ -f "$requirements_file" ]; then
        if ansible-galaxy install -r "$requirements_file"; then
            success "Ansible requirements installed successfully"
            return 0
        else
            error "Failed to install Ansible requirements"
            return 1
        fi
    else
        info "No requirements.yml found, skipping"
        return 0
    fi
}

check_ansible_syntax() {
    local platform="$1"
    local playbook="$2"

    local inventory_file="${ANSIBLE_INVENTORY_DIR}/${platform}/hosts.ini"
    local playbook_path="${ANSIBLE_PLAYBOOK_DIR}/${playbook}"

    step "Checking Ansible syntax for $playbook..."

    if ansible-playbook -i "$inventory_file" "$playbook_path" --syntax-check; then
        success "Ansible syntax is valid"
        return 0
    else
        error "Ansible syntax check failed"
        return 1
    fi
}

ansible_operation() {
    local platform="$1"
    local action="$2"
    local playbook="${3:-site.yaml}"
    local extra_options="$4"

    if ! is_ansible_platform_supported "$platform"; then
        error "Unsupported platform: $platform"
        info "Supported platforms: ${SUPPORTED_PLATFORMS[*]}"
        return 1
    fi

    if ! validate_ansible_directory; then
        return 1
    fi

    if ! validate_inventory "$platform"; then
        return 1
    fi

    set_ansible_env

    case "$action" in
        "ping")
            ansible_ping "$platform"
            ;;
        "facts")
            ansible_gather_facts "$platform"
            ;;
        "syntax-check")
            validate_playbook "$playbook" && check_ansible_syntax "$platform" "$playbook"
            ;;
        "check")
            validate_playbook "$playbook" && run_ansible_playbook "$platform" "$playbook" "$extra_options" "" "" "true"
            ;;
        "run"|"playbook")
            validate_playbook "$playbook" && run_ansible_playbook "$platform" "$playbook" "$extra_options"
            ;;
        "install-requirements")
            install_ansible_requirements
            ;;
        "adhoc")
            local module="${extra_options%%:*}"
            local args="${extra_options#*:}"
            ansible_adhoc "$platform" "$module" "$args"
            ;;
        *)
            error "Unknown Ansible action: $action"
            info "Supported actions: ping, facts, syntax-check, check, run, install-requirements, adhoc"
            return 1
            ;;
    esac
}

ansible_multi_platform() {
    local action="$1"
    local playbook="${2:-site.yaml}"
    shift 2
    local platforms=("$@")

    local failed_platforms=()

    for platform in "${platforms[@]}"; do
        header "ANSIBLE: $platform"
        if ! ansible_operation "$platform" "$action" "$playbook"; then
            failed_platforms+=("$platform")
        fi
        footer
    done

    if [ ${#failed_platforms[@]} -gt 0 ]; then
        error "Ansible failed for platforms: ${failed_platforms[*]}"
        return 1
    fi

    success "Ansible completed successfully for all platforms"
    return 0
}

wait_for_hosts() {
    local platform="$1"
    local timeout="${2:-300}"
    local interval="${3:-30}"

    step "Waiting for hosts to be ready (timeout: ${timeout}s)..."

    local elapsed=0
    while [ $elapsed -lt $timeout ]; do
        if ansible_ping "$platform" >/dev/null 2>&1; then
            success "All hosts are ready"
            return 0
        fi

        info "Hosts not ready yet, waiting ${interval}s... (${elapsed}/${timeout}s elapsed)"
        sleep $interval
        elapsed=$((elapsed + interval))
    done

    error "Timeout waiting for hosts to be ready"
    return 1
}

get_host_info() {
    local platform="$1"
    local inventory_file="${ANSIBLE_INVENTORY_DIR}/${platform}/hosts.ini"

    step "Getting host information for $platform..."

    if [ -f "$inventory_file" ]; then
        info "Inventory file: $inventory_file"
        echo "--- Host Groups ---"
        grep -E '^\[.*\]' "$inventory_file" | sed 's/\[//g; s/\]//g'
        echo ""
        echo "--- Hosts ---"
        grep -v -E '^\[|^$|^#' "$inventory_file"
    else
        error "Inventory file not found: $inventory_file"
        return 1
    fi
}

create_sample_inventory() {
    local platform="$1"
    local inventory_dir="${ANSIBLE_INVENTORY_DIR}/${platform}"
    local inventory_file="${inventory_dir}/hosts.ini"

    step "Creating sample inventory for $platform..."

    mkdir -p "$inventory_dir"

    cat > "$inventory_file" << 'EOF'


[masters]
master-1 ansible_host=192.168.1.10 ansible_user=ubuntu
master-2 ansible_host=192.168.1.11 ansible_user=ubuntu
master-3 ansible_host=192.168.1.12 ansible_user=ubuntu

[workers]
worker-1 ansible_host=192.168.1.20 ansible_user=ubuntu
worker-2 ansible_host=192.168.1.21 ansible_user=ubuntu
worker-3 ansible_host=192.168.1.22 ansible_user=ubuntu

[k8s_cluster:children]
masters
workers

[k8s_cluster:vars]
ansible_ssh_private_key_file=~/.ssh/id_rsa
ansible_ssh_common_args='-o StrictHostKeyChecking=no'
EOF

    success "Sample inventory created at: $inventory_file"
    info "Please edit this file with your actual host information"
}
